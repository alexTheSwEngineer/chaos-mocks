package com.alext.mutation


/**
 * This function creates a test input for every combination generated by the mutationCombinator and applies the assertions.
 * It expects the assertions to fail and will raise a MutationTestingAssertionError otherwise.
 * Input is generated by feeding the  inputGenerator parameter function  with  subsets (described by the combinations) of the list this extension  is called on.
 * For each input (combination) generated the assertions are applied.
 * @param this Any list of SetupType that can be used to generate a test input of type InputType
 * @param mutationCombinator A generator of mutation index sets. Each mutation describes a subset of the list this extension is being called on. Each subset is going to be used to generate input with the inputGenerator.
 * @param assertion The assertion that is going to be called fore every generated input (each generated subset of the setup list)
 * */
inline fun <reified SetupType : Any, reified InputType> List<SetupType>.assertAllFailForMutations(mutationCombinator: (List<SetupType>) -> Iterator<Set<Int>>, inputGenerator: (List<SetupType>) -> InputType, assertion: (InputType, Set<Int>) -> Unit) {
    this.assertForMutations(mutationCombinator, inputGenerator, true, assertion)
}


/**
 * This function creates a test input for every combination generated by the mutationCombinator and applies the assertions.
 * Input is generated by feeding the  inputGenerator parameter function  with  subsets (described by the combinations) of the list this extension  is called on.
 * For each input (combination) generated the assertions are applied.
 * @param this Any list of SetupType that can be used to generate a test input of type InputType
 * @param mutationCombinator A generator of mutation index sets. Each mutation describes a subset of the list this extension is being called on. Each subset is going to be used to generate input with the inputGenerator.
 * @param assertion The assertion that is going to be called fore every generated input (each generated subset of the setup list)
 * */
inline fun <reified SetupType : Any, reified MockType> List<SetupType>.assertAllForMutations(mutationCombinator: (List<SetupType>) -> Iterator<Set<Int>>, inputGenerator: (List<SetupType>) -> MockType, assertion: (MockType, Set<Int>) -> Unit) {
    this.assertForMutations(mutationCombinator, inputGenerator, false, assertion)
}

/**
 * This function creates a test input for every combination generated by the mutationCombinator and applies the assertions.
 * It expects the assertion to either pass or fail based on the parameter assertionShouldFail.
 * Input is generated by feeding the  inputGenerator parameter function  with  subsets (described by the combinations) of the list this extension  is called on.
 * For each input (combination) generated the assertions are applied
 * @param this Any list of SetupType that can be used to generate a test input of type InputType
 * @param mutationCombinator A generator of mutation index sets. Each mutation describes a subset of the list this extension is being called on. Each subset is going to be used to generate input with the inputGenerator.
 * @param assertion The assertion that is going to be called fore every generated input (each generated subset of the setup list)
 * @param assertionsShouldFail A flag indicating if the assertions are expected to pass, or fail.
 * */
inline fun <reified SetupType : Any, reified InputType> List<SetupType>.assertForMutations(mutationCombinator: (List<SetupType>) -> Iterator<Set<Int>>, inputGenerator: (List<SetupType>) -> InputType, assertionsShouldFail: Boolean, assertion: (InputType, Set<Int>) -> Unit) {
    val mutationIterator = mutationCombinator(this)
    while (mutationIterator.hasNext()) {
        val mutation = mutationIterator.next()
        val mutatedInput = mutation.map { this[it] }
                .let { inputGenerator(it) }

        try {
            assertion(mutatedInput, mutation)
        } catch (e: AssertionError) {
            if (assertionsShouldFail) {
                //If called with the usual assertions
                continue
            } else {
                //If called with mutation specific reversed assertions
                throw e
            }
        }

        if (assertionsShouldFail) {
            //If called with non mutation specific assertions, reaching this line means some assertion passed
            throw MutationTestingAssertionError("Mutation ${mutation.joinToString(",")} resulting in mutated input: ${mutatedInput} did not raise assertionError")
        }
    }
}